
/*******************************************************
 * ESP8266 Saving Values in Ram case internet offline
 *Cache Enought for 100Data readings
 *3 Days in hourly Averages Calculation
 * 05/2024 - Felipe Buhrer
 */
/********************************************************
*/
//Change you Wifi and Gsheets API credentials before use

//Debug State Set
#define DEBUG 0

#if DEBUG == 1
#define debug(x) Serial.print(x)
#define debugln(x) Serial.println(x)
#else
#define debug(x)
#define debugln(x)
#endif

#include <Arduino.h>                  //Overall librarie for commun methods
#include <ESP8266WiFi.h>              //Wifi conection for esp8266
#include <ESP_Google_Sheet_Client.h>  //Send data to Google Sheets
#include <NTPClient.h>                //Get the EPOCH time from web
#include <WiFiUdp.h>                  // Get the EPOCH time from web
#include <DHT.h>                      //Read DHT Sensors
#include <vector>                     //Save Ram Data
#include <String>                     //Save Ram Data
#include <ctime>                      //Save Ram Data

#include "envKeys.h"
unsigned long ms = 0;
unsigned long mr = 0;
unsigned long lastAttemptedReconnect = 0;
void tokenStatusCallback(TokenInfo info);

//Variables for testing on Google Sheets
String sheetAppend = "Dados!";        //Dados
String sheetValues = "Config!";  // Config

//Temperatura Termistor
#define Vin 3.25          // define constante igual a 5.0
#define T0 298.15         // define constante igual a 298.15 Kelvin
#define Rt 10000          // Resistor do divisor de tensao
#define R0 10000          // Valor da resistencia inicial do NTC
#define T1 273.15         // [K] in datasheet 0o C
#define T2 373.15         // [K] in datasheet 100° C
#define RT1 35563         // [ohms] resistencia in T1
#define RT2 549           // [ohms] resistencia in T2
float beta = 0.0;         // parametros iniciais [K]
float Rinf = 0.0;         // parametros iniciais [ohm]
float TempKelvin = 0.0;   // variable output
float TempCelsius = 0.0;  // variable output
float Vout = 0.0;         // Vout in A0
float Rout = 0.0;

//Define Pins and Sensors
#define mudasPin 2   //D4 turn On plants Relay, runs on Low
#define sprayPin 0   //D3 turn On Greenhouse Umidity Relay, runs on Low
#define DHTESTUFA 5  //D1 Sensor Temp Greenhouse
#define DHTMODULO 4  //D2 Sensor Temp Outside
#define MUXA 13      //D7 Mux channel A
#define MUXB 12      //D6 Mux channel B
#define MUXC 14      //D5 Mux channel C

//Sensores DHT 11
#define DHTTYPE DHT11
DHT dhtModulo(DHTMODULO, DHTTYPE);
float temperatureModulo = 0.0;
float humidityModulo = 0.0;
DHT dhtEstufa(DHTESTUFA, DHTTYPE);
float temperatureEstufa = 0.0;
float humidityEstufa = 0.0;

//ALL Sensors
//Termistor Sensor
float mediaVaristor = 0.0;
//LDR sensor
float lumPC = 0.0;
//Resistive Soil Moisture
float soilUmUm = 0.0;
//Sensor Umidade Solo Capacitivo 1
float soilCap1 = 0.0;
//Sensor Umidade Solo Capacitivo 2
float soilCap2 = 0.0;
//Average Calculation
long somatoria = 0;
int leitura_sensor = 0;
float media;
float leitura;
int NUMERO_AMOSTRAS = 40;  //Number of readings per Average

//Epoch Time Config
const long utcOffsetInSeconds = -10800;  //Ajuste de data e hora
// Define NTP Client to get time
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org");
//Variaveis data e hora
time_t epochTime;
int monthDay;
int currentMonth;
int currentYear;
String currentDate;
char formattedTime[9];


//---** Variables Changed on Sheets
//Time to Upate Config Interval
unsigned long recivingDataInterval = 300000;//5 minutes
//Greenhous Activity on/off
bool grenhouseON = 0;
int limiarEstufa = 80;
//Variables for cicle Delays and Irrigation system
int readingInterval = 60000;  // 1min
int limiteUmidade = 80;      //45%
unsigned long sendDataInterval = 600000;//10 minutes
unsigned long averageCalculationInterval = 300000;//5 minutes

//Counters
unsigned long lastReading = 0;
unsigned long lastSendedData = 0;
unsigned long lastAverage = 0;
unsigned long lastUpdate = 0;

int numAverages = 0; // Contador de médias calculadas
unsigned long maxTemp = 0; //Will be updated every cicle and send the max values
unsigned long minTemp = 80; //Will be updated every cicle and send the min values

enum State {
  IDLE,
  CHECK_SOIL_MOISTURE,
  IRRIGATION_ON,
  IRRIGATION_WAIT,
  IRRIGATION_OFF
};

State currentState = IDLE;
unsigned long previousMillis = 0;
unsigned long irrigationStartMillis = 0;
unsigned long tempoIrrigacao = 300000;  //5 min

// Variáveis globais para armazenar condições
bool isSpraying = false;

//--------------------------Methods
//Connect Wifi
void connectWiFi();

//**Sensors
//Mux Readings
void muxReadings();
//dht11
void Load_DHT11_Data();
//Leitura Sensores Resistivos
int readPin();
//Mux port selection code
void selectChannel();
//Calculate Epoch Dependent Variables
void epochCalculate(time_t);

//**Gsheets --
void tokenStatusCallback();
//Enviador de Dados
void loop_enviadorDados();
//Recebedor de Dados
void loop_receberDados();


//**Saving data to RAM
// Struct definition to save all data formats
struct Dados;
// Vector para armazenar os conjuntos de dados
std::vector<Dados> dadosArmazenados; //Uses array in stack for that
//Method for saving values in RAM
void saveValues();
void showDatainRAM();
void sendRamData();
void calculateAveragesAndClear();

//--------------Setup
void setup() {

  Serial.begin(115200);

  //DHT sensores
  dhtModulo.begin();
  dhtEstufa.begin();

  //Thermistor Calculation
  beta = (log(RT1 / RT2)) / ((1 / T1) - (1 / T2));  // calculo de beta
  Rinf = R0 * exp(-beta / T0);                      // calculo de Rinf

  // Mux pins as OUTPUTS
  pinMode(MUXA, OUTPUT);
  pinMode(MUXB, OUTPUT);
  pinMode(MUXC, OUTPUT);

  //Greenhouse relay pin
  pinMode(sprayPin, OUTPUT);
  digitalWrite(sprayPin, HIGH);

  //Irrigation System Pin
  pinMode(mudasPin, OUTPUT);
  digitalWrite(mudasPin, HIGH);

  //Client Check
  //GSheet.printf("ESP Google Sheet Client v%s\n\n", ESP_GOOGLE_SHEET_CLIENT_VERSION);

  //WiFi Novo
  connectWiFi();

  //Inicializando Gsheets
  if (WiFi.status() == WL_CONNECTED) {
    debugln("\nWi-Fi connected!");

    // Set the callback for Google API access token generation status (for debug only)
    GSheet.setTokenCallback(tokenStatusCallback);
    GSheet.setPrerefreshSeconds(10 * 60);
    GSheet.begin(CLIENT_EMAIL, PROJECT_ID, PRIVATE_KEY);

  } else {
    debugln("\nFailed to connect to Wi-Fi!");
  }

  // Initialize a NTPClient to get time
  timeClient.begin();
  timeClient.setTimeOffset(-10800);
}


void loop() {

  unsigned long currentMillis = millis();

  muxReadings();
  Load_DHT11_Data();
  debugln("******************");
  debugln(currentState);
  debugln("*******");

  // Updating Data
  if (currentMillis - lastUpdate > recivingDataInterval) {//1min teste
      debugln("Updating Values");
      loop_receberDados();
      lastUpdate=currentMillis;
  }


  switch (currentState) {
    debugln("**---Iniciando witch state ---");
    case IDLE:
      // Verifica a umidade do solo
      if (soilUmUm < limiteUmidade &&tempoIrrigacao> 0) {
        // Verifica se o pino da estufa está ligado e desliga se necessário
        if (isSpraying) {
          debugln("**Spray LIGADO Status Check condicao 1");
          digitalWrite(sprayPin, HIGH);
          isSpraying = false;
          debugln("**Spray DESLIGADO PELA CONDICAO 1");
        }
        // Liga o pino de irrigação e marca o início
        digitalWrite(mudasPin, LOW);
        debugln("Relé Irrigação Acionado");
        irrigationStartMillis = currentMillis;
        currentState = IRRIGATION_ON;
      } else if (grenhouseON && humidityEstufa < limiarEstufa) {
        digitalWrite(sprayPin, LOW);
        isSpraying = true;
        debugln("**Spray LIGADO pelo esleif da condição 1");
      } else if (!grenhouseON){
         digitalWrite(sprayPin, HIGH);
        isSpraying = false;
        debugln("**Spray DESLIGADO pelo esleif da condição 1");
      }
      break;

    case IRRIGATION_ON:
      currentState = IRRIGATION_WAIT;
      break;

    case IRRIGATION_WAIT:
      // Espera até que a duração da irrigação tenha passado
      if (currentMillis - irrigationStartMillis >= tempoIrrigacao) {
        digitalWrite(mudasPin, HIGH);
        debugln("Relé Irrigação Desligado");
        currentState = IRRIGATION_OFF;
      }
      break;

    case IRRIGATION_OFF:
      debugln("**Iniciando Condição 4");
      // Restaura o estado do pino da estufa se necessário
      if (humidityEstufa < limiarEstufa && grenhouseON) {
        digitalWrite(sprayPin, LOW);
        debugln("**Spray LIGADO pela condicao 4");
      }
      currentState = IDLE;
      isSpraying = true;

      break;
  }

  //Reading Iterval
  if (currentMillis - lastReading >= readingInterval) {

    if (WiFi.status() == WL_CONNECTED) {

      timeClient.update();
      epochTime = timeClient.getEpochTime();
      saveValues();
    } else {
      epochTime = epochTime + (readingInterval / 1000);
      saveValues();
    }

    lastReading = currentMillis;
  }

  //Send Data 
  if (WiFi.status() == WL_CONNECTED) {
    if (currentMillis - lastSendedData >= sendDataInterval) {

      calculateSubsetAveragesAndStore();
      sendRamData();
      lastSendedData = currentMillis;
    }
  } else {
   if (currentMillis - lastAttemptedReconnect >= 500) {
      lastAttemptedReconnect = currentMillis;
      connectWiFi(); // Tentar reconectar
    }
  }
  
  // Average Data
  if (currentMillis - lastAverage > averageCalculationInterval) {//1min teste
      Serial.println("Invoking AverageAndStore");
      calculateSubsetAveragesAndStore();
      lastAverage=currentMillis;
  }



  // Verifica a quantidade de memória heap livre
  //size_t freeHeap = ESP.getFreeHeap();
  //Serial.print("Free heap: ");
  //Serial.print(freeHeap);
  //Serial.println(" bytes");

  //Serial.print("Tamanho dados armazenados :");
  //Serial.println(dadosArmazenados.size());


}