
/*******************************************************
 * ESP8266 Saving Values in Ram case internet offline
 * 05/2024 - Felipe Buhrer
 */
/********************************************************
*/
//Change you Wifi and Gsheets API credentials before use

//Debug State Set
#define DEBUG 0

#if DEBUG == 1
#define debug(x) Serial.print(x)
#define debugln(x) Serial.println(x)
#else
#define debug(x)
#define debugln(x)
#endif

#include <Arduino.h>                  //Overall librarie for commun methods
#include <ESP8266WiFi.h>              //Wifi conection for esp8266
#include <ESP_Google_Sheet_Client.h>  //Send data to Google Sheets
#include <NTPClient.h>                //Get the EPOCH time from web
#include <WiFiUdp.h>                  // Get the EPOCH time from web
#include <DHT.h>                      //Read DHT Sensors
#include <vector>                     //Save Ram Data
#include <String>                     //Save Ram Data
#include <ctime>                      //Save Ram Data

#include "envKeys.h"
unsigned long ms = 0;
unsigned long mr = 0;
void tokenStatusCallback(TokenInfo info);

//Variables for testing on Google Sheets
String sheetAppend = "Teste!";        //Dados
String sheetValues = "TemposTeste!";  // Config

//Temperatura Termistor
#define Vin 3.25          // define constante igual a 5.0
#define T0 298.15         // define constante igual a 298.15 Kelvin
#define Rt 10000          // Resistor do divisor de tensao
#define R0 10000          // Valor da resistencia inicial do NTC
#define T1 273.15         // [K] in datasheet 0o C
#define T2 373.15         // [K] in datasheet 100° C
#define RT1 35563         // [ohms] resistencia in T1
#define RT2 549           // [ohms] resistencia in T2
float beta = 0.0;         // parametros iniciais [K]
float Rinf = 0.0;         // parametros iniciais [ohm]
float TempKelvin = 0.0;   // variable output
float TempCelsius = 0.0;  // variable output
float Vout = 0.0;         // Vout in A0
float Rout = 0.0;

//Define Pins and Sensors
//2 pins for valves outputs - D3 and D4
//2 Pins for DHT reading - D1 and D2
//3 pins for comunication with MUX - D5, D6, D7
#define mudasPin 2   //D4 turn On plants Relay, runs on Low
#define sprayPin 0   //D3 turn On Greenhouse Umidity Relay, runs on Low
#define DHTESTUFA 5  //D1 Sensor Temp Greenhouse
#define DHTMODULO 4  //D2 Sensor Temp Outside
#define MUXA 13      //D7 Mux channel A
#define MUXB 12      //D6 Mux channel B
#define MUXC 14      //D5 Mux channel C

//Sensores DHT 11
#define DHTTYPE DHT11
DHT dhtModulo(DHTMODULO, DHTTYPE);
float temperatureModulo = 0.0;
float humidityModulo = 0.0;
DHT dhtEstufa(DHTESTUFA, DHTTYPE);
float temperatureEstufa = 0.0;
float humidityEstufa = 0.0;
//ALL Sensors
//Termistor Sensor
float mediaVaristor = 0.0;
//LDR sensor
float lumPC = 0.0;
//Resistive Soil Moisture
float soilUmUm = 0.0;
//Sensor Umidade Solo Capacitivo 1
float soilCap1 = 0.0;
//Sensor Umidade Solo Capacitivo 2
float soilCap2 = 0.0;
//Average Calculation
long somatoria = 0;
int leitura_sensor = 0;
float media;
float leitura;

//Epoch Time Config
const long utcOffsetInSeconds = -10800;  //Ajuste de data e hora
// Define NTP Client to get time
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org");
//Variaveis data e hora
time_t epochTime;
int monthDay;
int currentMonth;
int currentYear;
String currentDate;
String formattedTime;


//---** Variables Intervals
//Greenhous Activity on/off
bool grenhouseON = 0;
int limiarEstufa = 80;

//Variables for cicle Delays and Irrigation system
int readingInterval = 6000;  // 10 min
int limiteUmidade = 80;      //45%
unsigned long lastReading = 0;
unsigned long lastSendedData = 0;
unsigned long sendDataInterval = 60000;

const int NUMERO_AMOSTRAS = 40;  //Amostras para mandar apenas a media para a planilha
const size_t MAX_DATA_SETS = 60; //Max sets before average calculation

enum State {
  IDLE,
  CHECK_SOIL_MOISTURE,
  IRRIGATION_ON,
  IRRIGATION_WAIT,
  IRRIGATION_OFF
};

State currentState = IDLE;
unsigned long previousMillis = 0;
unsigned long irrigationStartMillis = 0;
unsigned long tempoIrrigacao = 300000;  //5 min

// Variáveis globais para armazenar condições
bool isSpraying = false;

//--------------------------Methods
//Connect Wifi
void connectWiFi();

//**Sensors
//Mux Readings
void muxReadings();
//dht11
void Load_DHT11_Data();
//Leitura Sensores Resistivos
int readPin();
//Mux port selection code
void selectChannel();
//Calculate Epoch Dependent Variables
void epochCalculate(time_t);

//**Gsheets --
void tokenStatusCallback();
//Enviador de Dados
void loop_enviadorDados();
//Recebedor de Dados
void loop_receberDados();


//**Saving data to RAM
// Struct definition to save all data formats
struct Dados;
// Vector para armazenar os conjuntos de dados
std::vector<Dados> dadosArmazenados;
//Method for saving values in RAM
void saveValues();
void showDatainRAM();
void sendRamData();
void calculateAveragesAndClear();

//--------------Setup
void setup() {

  Serial.begin(115200);

  //DHT sensores
  dhtModulo.begin();
  dhtEstufa.begin();

  //Thermistor Calculation
  beta = (log(RT1 / RT2)) / ((1 / T1) - (1 / T2));  // calculo de beta
  Rinf = R0 * exp(-beta / T0);                      // calculo de Rinf

  // Mux pins as OUTPUTS
  pinMode(MUXA, OUTPUT);
  pinMode(MUXB, OUTPUT);
  pinMode(MUXC, OUTPUT);

  //Greenhouse relay pin
  pinMode(sprayPin, OUTPUT);
  digitalWrite(sprayPin, HIGH);

  //Irrigation System Pin
  pinMode(mudasPin, OUTPUT);
  digitalWrite(mudasPin, HIGH);

  //Client Check
  //GSheet.printf("ESP Google Sheet Client v%s\n\n", ESP_GOOGLE_SHEET_CLIENT_VERSION);

  //WiFi Novo
  connectWiFi();

  //Inicializando Gsheets
  if (WiFi.status() == WL_CONNECTED) {
    debugln("\nWi-Fi connected!");

    // Set the callback for Google API access token generation status (for debug only)
    GSheet.setTokenCallback(tokenStatusCallback);
    GSheet.setPrerefreshSeconds(10 * 60);
    GSheet.begin(CLIENT_EMAIL, PROJECT_ID, PRIVATE_KEY);

  } else {
    debugln("\nFailed to connect to Wi-Fi!");
  }

  // Initialize a NTPClient to get time
  timeClient.begin();
  timeClient.setTimeOffset(-10800);
}


void loop() {

  unsigned long currentMillis = millis();

  muxReadings();
  Load_DHT11_Data();
  debugln("******************");
  debugln(currentState);
  debugln("*******");

  switch (currentState) {
    debugln("**---Iniciando witch state ---");
    case IDLE:
      // Verifica a umidade do solo
      if (soilUmUm < limiteUmidade) {
        // Verifica se o pino da estufa está ligado e desliga se necessário
        if (isSpraying) {
          debugln("**Spray LIGADO Status Check condicao 1");
          digitalWrite(sprayPin, HIGH);
          isSpraying = false;
          debugln("**Spray DESLIGADO PELA CONDICAO 1");
        }
        // Liga o pino de irrigação e marca o início
        digitalWrite(mudasPin, LOW);
        debugln("Relé Irrigação Acionado");
        irrigationStartMillis = currentMillis;
        currentState = IRRIGATION_ON;
      } else if (grenhouseON && humidityEstufa < limiarEstufa) {
        digitalWrite(sprayPin, LOW);
        isSpraying = true;
        debugln("**Spray LIGADO pelo esleif da condição 1");
      }
      break;

    case IRRIGATION_ON:
      currentState = IRRIGATION_WAIT;
      break;

    case IRRIGATION_WAIT:
      // Espera até que a duração da irrigação tenha passado
      if (currentMillis - irrigationStartMillis >= tempoIrrigacao) {
        digitalWrite(mudasPin, HIGH);
        debugln("Relé Irrigação Desligado");
        currentState = IRRIGATION_OFF;
      }
      break;

    case IRRIGATION_OFF:
      debugln("**Iniciando Condição 4");
      // Restaura o estado do pino da estufa se necessário
      if (humidityEstufa < limiarEstufa) {
        digitalWrite(sprayPin, LOW);
        debugln("**Spray LIGADO pela condicao 4");
      }
      currentState = IDLE;
      isSpraying = true;

      break;
  }

  if (currentMillis - lastReading >= readingInterval) {

    if (WiFi.status() == WL_CONNECTED) {

      timeClient.update();
      epochTime = timeClient.getEpochTime();
      epochCalculate(epochTime);
      saveValues();
    } else {
      epochTime = epochTime + (readingInterval / 1000);
      epochCalculate(epochTime);
      saveValues();
    }

    lastReading = currentMillis;
  }


  if (WiFi.status() == WL_CONNECTED) {
    if (currentMillis - lastSendedData >= sendDataInterval) {
      sendRamData();
      loop_receberDados();
      lastSendedData = currentMillis;
    }
  } else {
    //WiFi.disconnect();
    delay(500);

    connectWiFi();
  }
    // Simular a adição de dados
  if (dadosArmazenados.size() > MAX_DATA_SETS) {
      calculateAveragesAndClear();
  }

  // Verifica a quantidade de memória heap livre
  size_t freeHeap = ESP.getFreeHeap();
  Serial.print("Free heap: ");
  Serial.print(freeHeap);
  Serial.println(" bytes");

  Serial.print("Tamanho dados armazenados :");
  Serial.println(dadosArmazenados.size());


}



//----DELETAR
/*


  if (WiFi.status() == WL_CONNECTED) {
    // Envie os dados da RAM caso Tenha iternet e dados na RAM
    if (currentMillis - lastSendTime >= sendInterval || !dadosArmazenados.empty()) {
      if (!dadosArmazenados.empty()) {
        // Enviar os dados armazenados
        bool success = sendRamData();
        if (success) {

          lastSendTime = currentMillis;  // Atualiza o tempo do último envio
        }
      } else {
        // Enviar dados atuais
        //Atualizar as variaveis aqui
        timeClient.update();
        epochTime = timeClient.getEpochTime();
        epochCalculate(epochTime);


        bool success = loop_enviadorDados();
        if (success) {
          lastSendTime = currentMillis;  // Atualiza o tempo do último envio
        } else {
          // Salva os dados atuais se o envio falhar
          saveValues();
        }
      }
    } else {
      debugln("Disconnected from Wi-Fi. Reconnecting...");

      WiFi.disconnect();
      delay(500);

      connectWiFi();

      epochTime = epochTime + (tempoCiclo / 1000);
      epochCalculate(epochTime);

      saveValues();
    }






    bool conectionError = true;

    for (int i = 0; i < 3; i++) {
      if (GSheet.ready()) {
        // Se a conexão estiver pronta, execute as funções relacionadas ao Google Sheets
        loop_enviadorDados();
        loop_receberDados();
        conectionError = false;
        break;  // Sai do loop de tentativas se a conexão estiver pronta
      } else {
        // Set the callback for Google API access token generation status (for debug only)
        //GSheet.setTokenCallback(tokenStatusCallback);

        debugln("Trying to reconnect to Google Sheets...");
        GSheet.setPrerefreshSeconds(10 * 60);
        GSheet.begin(CLIENT_EMAIL, PROJECT_ID, PRIVATE_KEY);
        delay(5000);  // Aguarda um curto período antes de tentar novamente
      }
    }

    if (conectionError) {
      saveValues();
    }
  } else {
    debugln("Disconnected from Wi-Fi. Reconnecting...");

    WiFi.disconnect();
    delay(500);

    connectWiFi();

    epochTime = epochTime + (tempoCiclo / 1000);
    epochCalculate(epochTime);

    saveValues();
  }

  delay(30000);

if (!dadosArmazenados.empty() && WiFi.status() == WL_CONNECTED) {
  // Enviar os dados armazenados
  sendRamData();
}



//showDatainRAM();

//debugln("Cicle Delay: ");
//debug(tempoCiclo);
//delay(tempoCiclo);

*/
