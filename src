
/*******************************************************
 * ESP8266 Adding Sensors and Google Sheet Records
 * 01/2024 - Felipe Buhrer
 */
/********************************************************
*/
//Change you Wifi and Gsheets API credentials before use

//Debug State Set
#define DEBUG 1

#if DEBUG == 1 
#define debug(x) Serial.print(x)
#define debugln(x) Serial.println(x)
#else
#define debug(x)
#define debugln(x)
#endif


#include <Arduino.h>
#include <ESP8266WiFi.h>
#include <ESP_Google_Sheet_Client.h>
#include <NTPClient.h>
#include <WiFiUdp.h>
#include <DHT.h>
#include <vector>


//Wifi com 2 redes
//const char *ssid[] = { "Zezinho", "jose" };
const char *ssid[] = { "NHAZINHA (EVENTOS)_EXT", "Nhazinha", "Nhazinha Extendida" };
const char *password = "014280639";
const int numNetworks = sizeof(ssid) / sizeof(ssid[0]);

//Temperatura Termistor
#define Vin 3.25          // define constante igual a 5.0
#define T0 298.15         // define constante igual a 298.15 Kelvin
#define Rt 10000          // Resistor do divisor de tensao
#define R0 10000          // Valor da resistencia inicial do NTC
#define T1 273.15         // [K] in datasheet 0o C
#define T2 373.15         // [K] in datasheet 100° C
#define RT1 35563         // [ohms] resistencia in T1
#define RT2 549           // [ohms] resistencia in T2
float beta = 0.0;         // parametros iniciais [K]
float Rinf = 0.0;         // parametros iniciais [ohm]
float TempKelvin = 0.0;   // variable output
float TempCelsius = 0.0;  // variable output
float Vout = 0.0;         // Vout in A0
float Rout = 0.0;

//Define Pins and Sensors
//2 pins for valves outputs - D3 and D4
//2 Pins for DHT reading - D1 and D2
//3 pins for comunication with MUX - D5, D6, D7
#define mudasPin 2   //D4 turn On plants Relay, runs on Low
#define sprayPin 0   //D3 turn On Greenhouse Umidity Relay, runs on Low
#define DHTESTUFA 5  //D1 Sensor Temp Greenhouse
#define DHTMODULO 4  //D2 Sensor Temp Outside
#define MUXA 13      //D7 Mux channel A
#define MUXB 12      //D6 Mux channel B
#define MUXC 14      //D5 Mux channel C

//Sensores DHT 11
#define DHTTYPE DHT11
DHT dhtModulo(DHTMODULO, DHTTYPE);
float temperatureModulo = 0.0;
float humidityModulo = 0.0;
DHT dhtEstufa(DHTESTUFA, DHTTYPE);
float temperatureEstufa = 0.0;
float humidityEstufa = 0.0;

//Termistor Sensor
float mediaVaristor = 0.0;

//LDR sensor
float lumPC = 0.0;

//Resistive Soil Moisture
float soilUmUm = 0.0;

//Sensor Umidade Solo Capacitivo 1
float soilCap1 = 0.0;

//Sensor Umidade Solo Capacitivo 2
float soilCap2 = 0.0;

//Greenhous Activity on/off
bool grenhouseON = 0;
int limiarEstufa = 80;

//Variables for cicle Delays and Irrigation system
int tempoCiclo = 6000;      // 10 min
int tempoIrrigacao = 300000;  //5 min
int limiteUmidade = 80;       //45%

const int NUMERO_AMOSTRAS = 40;  //Amostras para mandar apenas a media para a planilha
long somatoria = 0;
int leitura_sensor = 0;
float media;
float leitura;


//GSheets
#define PROJECT_ID "estufas-414918"
// Service Account's client email
#define CLIENT_EMAIL "valvulasestufas@estufas-414918.iam.gserviceaccount.com"
// Service Account's private key
const char PRIVATE_KEY[] PROGMEM = "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDD04BqR9aTLWZ3\njNivjojqrHLVypjXFjiP1JIbyLotl4gP+HG0psoKufNmf78KuFidpeyY+DyLle5z\n0QI7+RHjXK/c4xTGdlhXCYlxhIGPtV9HGIuqGiO3BlRo35+EuG29EmlUXu71uCEb\nheLqz+ZjFFJfiCqdgEK7bp/id3SJmAJj3kqLjO8CRKDP4/XhBYMYfn+2doIv6CqG\nnaFrdOByGAAEy7QhJ/N+qRpXpN9vX95wEvK3aO4mwKQbxU7SMbhx7tV0n9B2/2mz\nwNmZSYFNOSieiCok7r2x9ovrACiE0YtgNgDi7VJsb3Xql6cDEwSFLHJzYSUypOpT\naE8sG4snAgMBAAECggEAB82gQtvs+X1oJWBn7Ar2er93bfx+Paflhhm23sOPY6yz\nn8tLIKM6ztWdFNsHTlKNOW74sBnIM9m8IEJWX/RrWY+CdH9Z/xSNLZ60KuFYVlUo\nYElim1siTDNE3s72aM/+k3et2c5UoFb/frzFj4zMRetz4tmmtRL81cIxPdF7w9XI\nahLrhq7oIcFAF2k87/TlIeUZjnPg+CufasbJ8MrHc0HGfImPXoGRzC36BBj2DAi0\n2l5M6koOr1l9eXAiG2lB4W/NYahPJw7c2PCJLphBHxdlkzNNqvFG+8otPa0DtTGu\nfH0D8Zx8jDEeRiLzm9j034DzRo6yHST9karNPisY7QKBgQD2GYRHNychAK/zH+1p\nwFoNM4nykMTDQtd8lce5x6Nnwzm/3E/1LuFcGQoiHnICjeSQmRb0f6K9p3XI8kD3\nGhhzNhAlp+3PY3HQL9tKgGsIyomBmUGdMu36WlQA72Y1aDtoDz0ehgjOs2O7pGej\n5UNvOaVECgor21a3BHGctv4oRQKBgQDLtDzwGyfrDjzo1Naa6SdC16ZUbtRbeMuD\nHMfqIbavn8x705Ysb+eSkbTooTVlunESO0B8nbnXJ2Snm0SSMD7JW0UYQJg90VVw\nXOSdpDjU0aVX2n+RFmByEhGB7f/ccl8s9JSoRNVnFMihf0RHqF3yeXix3cAwsYes\nQm3CyDWKewKBgQC1sCD4cr9wnhFIbUnZySiyllpBup+JiM+OKwZJIhqBgKAiBYUC\nfpniZJoWlmOVfyw/lMZdu91qJzfOIwvTYnCqnj9Nja0Eb2aXTL2ZQzXCR8U86OiI\nJhGLwyRBjHzo8QrqyFVXM51M/SOkZLwfRCOE+goJMWBRAJ4EgENgb7k0AQKBgAfC\n4UOAtV+mVjnEyjxyv7UzRDoZUuv9STvAn/lSuYQtgXwCTsl4pgkWlh767W7n0KES\nMt3MoKUK8jHUn6M2RV4kpRhMdcB9NlUmpOtAs42gQz16rLuZb6lI+PPLXqFGlku/\nMd7LaJoZ158Xm0Fjr9iqOigEu+rfCL1OdqIiQK/7AoGAN1B8A/SnY6LUNSEFyrur\nzuucXBMhfG6WBCs4tY2P35adfAlPg5TBUlyZc4zso7NR2xjxjb+EnqgrI4SsHiOT\n4YSNAfxRhugVm/w7z35/jFXQDTX6TNQ4TNCItvQe8itjpEXz1tVyutLUnRgAOTYL\nBVLlGGamAEIkO9/FPGA6A88=\n-----END PRIVATE KEY-----\n";
unsigned long ms = 0;
unsigned long mr = 0;
void tokenStatusCallback(TokenInfo info);

//Epoch Time Config
const long utcOffsetInSeconds = -10800;  //Ajuste de data e hora
// Define NTP Client to get time
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org");
//Variaveis data e hora
time_t epochTime;
int monthDay;
int currentMonth;
int currentYear;
String currentDate;
String formattedTime;


//--------------------------Métodos
//Conectar Wifi
void connectWiFi() {
  debugln("Tentando conectar ao WiFi...");

  for (int i = 0; i < numNetworks; i++) {
    WiFi.mode(WIFI_OFF);
    delay(1000);
    //This line hides the viewing of ESP as wifi hotspot
    WiFi.mode(WIFI_STA);

    WiFi.begin(ssid[i], password);  // Tentativa de conexão com a rede atual

    unsigned long startTime = millis();  // Tempo inicial de tentativa de conexão

    while (WiFi.status() != WL_CONNECTED && millis() - startTime < 60000) {
      delay(500);
      debug(".");
    }

    if (WiFi.status() == WL_CONNECTED) {
      debugln("\nConectado ao WiFi!");
      return;  // Se a conexão for bem-sucedida, interrompa o loop e retorne
    } else {
      debugln("\nFalha ao conectar ao WiFi!");
      WiFi.disconnect();  // Desconecta do WiFi atual antes de tentar o próximo
    }
  }

  debugln("Todas as tentativas de conexão falharam.");
}

//Gsheets --
void tokenStatusCallback(TokenInfo info) {
  if (info.status == token_status_error) {
    GSheet.printf("Token info: type = %s, status = %s\n", GSheet.getTokenType(info).c_str(), GSheet.getTokenStatus(info).c_str());
    GSheet.printf("Token error: %s\n", GSheet.getTokenError(info).c_str());
  } else {
    GSheet.printf("Token info: type = %s, status = %s\n", GSheet.getTokenType(info).c_str(), GSheet.getTokenStatus(info).c_str());
  }
}

//dht11
void Load_DHT11_Data() {

  //Leitura Modulo
  //-----------------------------------------------------------
  temperatureModulo = dhtModulo.readTemperature();  //Celsius
  humidityModulo = dhtModulo.readHumidity();
  //-----------------------------------------------------------
  // Check if any reads failed.
  if (isnan(temperatureModulo) || isnan(humidityModulo)) {
    debugln("Failed to read from DHT Modulo sensor!");
    temperatureModulo = 0.0;
    humidityModulo = 0.0;
  }
  //-----------------------------------------------------------
  Serial.printf("Temperature Outside: %f °C\n", temperatureModulo);
  Serial.printf("Humidity Outside: %f %%\n", humidityModulo);

  //Leitura Estufa
  //-----------------------------------------------------------
  temperatureEstufa = dhtEstufa.readTemperature();  //Celsius
  humidityEstufa = dhtEstufa.readHumidity();
  //-----------------------------------------------------------
  // Check if any reads failed.
  if (isnan(temperatureEstufa) || isnan(humidityEstufa)) {
    debugln("Failed to read from DHT Estufa sensor!");
    temperatureEstufa = 0.0;
    humidityEstufa = 0.0;
  }
  //-----------------------------------------------------------
  Serial.printf("Temperature Estufa: %f °C\n", temperatureEstufa);
  Serial.printf("Humidity Estufa: %f %%\n", humidityEstufa);
}


//Leitura Sensores Resistivos
int readPin() {

  media = 0;
  somatoria = 0;
  analogRead(A0);
  for (int i = 1; i <= NUMERO_AMOSTRAS; i++) {
    int r;
    r = analogRead(A0);
    somatoria = somatoria + r;
  }
  media = somatoria / NUMERO_AMOSTRAS;
  delay(1000);
  return media;
}

//Enviador de Dados
void loop_enviadorDados() {

  bool ready = GSheet.ready();
  if (ready && millis() - ms > 15000) {
    ms = millis();

    FirebaseJson response;

    debugln("\nAppend spreadsheet values...");
    debugln("----------------------------");

    FirebaseJson valueRange;
    //Dados em linha
    valueRange.add("majorDimension", "ROWS");
    //rawdate
    valueRange.set("values/[0]/[0]", epochTime);
    //data
    valueRange.set("values/[0]/[1]", currentDate);
    //hora
    valueRange.set("values/[0]/[2]", formattedTime);
    //Temperatura Externa
    valueRange.set("values/[0]/[3]", temperatureModulo);
    //Umidade do AR Externo
    valueRange.set("values/[0]/[4]", humidityModulo);
    //Temperatura Termistor
    valueRange.set("values/[0]/[5]", TempCelsius);
    //Umidade Solo 1 Resistivo Externo Mudas
    valueRange.set("values/[0]/[6]", soilUmUm);
    //Luminosidade
    valueRange.set("values/[0]/[7]", lumPC);
    //Umidade Solo Capacitivo 1 - Provavelmente Estufas
    valueRange.set("values/[0]/[8]", soilCap1);
    //Umidade Solo Capacitivo 2
    valueRange.set("values/[0]/[9]", soilCap2);
    //Temperatura Estufa
    valueRange.set("values/[0]/[10]", temperatureEstufa);
    //Umidade do AR Estufa
    valueRange.set("values/[0]/[11]", humidityEstufa);


    bool success = GSheet.values.append(&response /* returned response */, "1ghTXvGyQEu-iUEI7eEYKt2wTln5SJcn2WORhD5_FF_o" /* spreadsheet Id to append */, "Dados!A2" /* range to append */, &valueRange /* data range to append */);
    if (success) {

      response.toString(Serial, true);
    } else {

      debugln(GSheet.errorReason());
      debugln();
    }
    debugln(ESP.getFreeHeap());
  } else {
    return;
  }
}

//Recebedor de Dados
void loop_receberDados() {
  bool ready = GSheet.ready();
  debugln("Receber Dados Iniciando");

  if (ready && millis() - mr > 15000) {
    mr = millis();
    debugln("--Gsheet Ready--");

    FirebaseJson response2;
    FirebaseJsonData result;   //Tempo Ciclo
    FirebaseJsonData result2;  //Limiar Estufa
    FirebaseJsonData result3;  //Estufa Ligada
    FirebaseJsonData result4;  //Tempo Irrigacao
    FirebaseJsonData result5;  //Valor Limite Irrigação


    debugln("Get spreadsheet values from range...");
    debugln("---------------------------------------------------------------");

    bool success = GSheet.values.get(&response2, "1ghTXvGyQEu-iUEI7eEYKt2wTln5SJcn2WORhD5_FF_o", "Config!A2:E2");

    response2.get(result /* FirebaseJsonData */, "values/[0]/[0]" /* key or path */);

    response2.get(result2 /* FirebaseJsonData */, "values/[0]/[1]" /* key or path */);

    response2.get(result3 /* FirebaseJsonData */, "values/[0]/[2]" /* key or path */);

    response2.get(result4 /* FirebaseJsonData */, "values/[0]/[3]" /* key or path */);

    response2.get(result5 /* FirebaseJsonData */, "values/[0]/[4]" /* key or path */);



    response2.toString(Serial, true);


    debugln("Delay betwen Cicles:");
    tempoCiclo = result.to<int>();
    debugln(tempoCiclo);

    debugln("Greenhouse Humidity Treshold Limit");
    limiarEstufa = result2.to<int>();
    debugln(limiarEstufa);

    debugln("Grenhouse on/off Status:");
    grenhouseON = result3.to<int>();
    debugln(grenhouseON);

    debugln("New Irrigation Time:");
    tempoIrrigacao = result4.to<int>();
    debugln(tempoIrrigacao);

    debugln("Soil Humidity Treshold Limit");
    limiteUmidade = result5.to<int>();
    debugln(limiteUmidade);


  } else {
    return;
  }
}
//Mux port selection code
void selectChannel(int channel) {
  digitalWrite(MUXA, bitRead(channel, 0));
  digitalWrite(MUXB, bitRead(channel, 1));
  digitalWrite(MUXC, bitRead(channel, 2));
}
//Change place after finish ->>>

#include <String>
#include <ctime>

// Definição da struct para armazenar os diferentes tipos de dados
struct Dados {
  time_t epochTime;
  String currentDate;
  String formattedTime;
  float temperatureModulo;
  float humidityModulo;
  float TempCelsius;
  float soilUmUm;
  float lumPC;
  float soilCap1;
  float soilCap2;
  float temperatureEstufa;
  float humidityEstufa;
};
// Vetor para armazenar os conjuntos de dados
std::vector<Dados> dadosArmazenados;

//Method for saving values in RAM
void saveValues() {
  
  Dados dadosEstruturados;
  dadosEstruturados.epochTime = epochTime;
  dadosEstruturados.currentDate = currentDate;
  dadosEstruturados.formattedTime = formattedTime;
  dadosEstruturados.temperatureModulo = temperatureModulo;
  dadosEstruturados.humidityModulo = humidityModulo;
  dadosEstruturados.TempCelsius = TempCelsius;
  dadosEstruturados.soilUmUm = soilUmUm;
  dadosEstruturados.lumPC = lumPC;
  dadosEstruturados.soilCap1 = soilCap1;
  dadosEstruturados.soilCap2 = soilCap2 ;
  dadosEstruturados.temperatureEstufa = temperatureEstufa;
  dadosEstruturados.humidityEstufa = temperatureEstufa;
   
  // Adicione o conjunto de dados ao vetor dadosArmazenados
  dadosArmazenados.push_back(dadosEstruturados);
}

//--------------Setup
void setup() {

  Serial.begin(115200);

  //DHT sensores
  dhtModulo.begin();
  dhtEstufa.begin();

  //Thermistor Calculation
  beta = (log(RT1 / RT2)) / ((1 / T1) - (1 / T2));  // calculo de beta
  Rinf = R0 * exp(-beta / T0);                      // calculo de Rinf


  // Mux pins as OUTPUTS
  pinMode(MUXA, OUTPUT);
  pinMode(MUXB, OUTPUT);
  pinMode(MUXC, OUTPUT);


  //Greenhouse relay pin
  pinMode(sprayPin, OUTPUT);
  digitalWrite(sprayPin, HIGH);

  //Irrigation System Pin
  pinMode(mudasPin, OUTPUT);
  digitalWrite(mudasPin, HIGH);

  //Client Check
  //GSheet.printf("ESP Google Sheet Client v%s\n\n", ESP_GOOGLE_SHEET_CLIENT_VERSION);

  //WiFi Novo
  connectWiFi();


  //Inicializando Gsheets
  if (WiFi.status() == WL_CONNECTED) {
    debugln("\nWi-Fi connected!");

    // Set the callback for Google API access token generation status (for debug only)
    GSheet.setTokenCallback(tokenStatusCallback);

    GSheet.setPrerefreshSeconds(10 * 60);
    GSheet.begin(CLIENT_EMAIL, PROJECT_ID, PRIVATE_KEY);

  } else {
    debugln("\nFailed to connect to Wi-Fi!");
  }

  // Initialize a NTPClient to get time
  timeClient.begin();
  timeClient.setTimeOffset(-10800);
}

void loop() {

  //MUX Readings
  for (int channel = 0; channel < 8; channel++) {
    //Chanel 0,1 and 3 are avaiable
    selectChannel(channel);  // Seleciona o canal do MUX

    //Varistor Temperature
    if (channel == 2) {
      leitura = 0;
      leitura = readPin();
      Vout = Vin * ((float)(media) / 1023.0);    // calculo de V0 e leitura de A0
      Rout = (Rt * Vout / (Vin - Vout));         // calculo de Rout
      TempKelvin = (beta / log(Rout / Rinf));    // calculo da temp. em Kelvins
      TempCelsius = TempKelvin - 273.15;         // calculo da temp. em Celsius
      debug("Temperatura em Celsius: ");  // imprime no monitor serial
      debugln(TempCelsius);               // imprime temperatura Celsius

    }

    else if (channel == 4) {
      //Have a 10k resistor between pin and 3.3v
      //Soil Moisture Resistive sensor
      leitura = 0;
      leitura = readPin();
      soilUmUm = map(leitura, 0, 1023, 100, 0);
      debug("Umidade Resistiva do Solo 1 em : ");
      debug(soilUmUm);
      debugln("%");
    }

    else if (channel == 5) {
      //Have a 10k resistor between pin and 3.3v
      //Luminosity Reading
      leitura = 0;
      leitura = readPin();
      lumPC = map(leitura, 0, 1023, 100, 0);
      debugln();
      debug("Luminosidade em : ");
      debug(lumPC);
      debugln("%");

    }

    else if (channel == 6) {

      //Capacitive Sensor
      leitura = 0;
      leitura = readPin();
      soilCap1 = map(leitura, 0, 1023, 100, 0);
      debugln();
      debug("Capacity Humidity Reading : ");
      debug(soilCap1);
      debugln("%");

    } else if (channel == 7) {

      //Capacitive Sensor
      leitura = 0;
      leitura = readPin();
      soilCap2 = map(leitura, 0, 1023, 100, 0);
      debugln();
      debug("Capacity Humidity Reading : ");
      debug(soilCap2);
      debugln("%");
    }
  }

  Load_DHT11_Data();

  // Verifica se a conexão com a Internet está ativa a cada intervalo de tempo
  if (WiFi.status() == WL_CONNECTED) {

    //Inserir data e hora
    timeClient.update();
    epochTime = timeClient.getEpochTime();
    debug("Epoch Time: ");
    debugln(epochTime);

    //Get a time structure
    struct tm *ptm = gmtime((time_t *)&epochTime);

    monthDay = ptm->tm_mday;
    debug("Month day: ");
    debugln(monthDay);

    currentMonth = ptm->tm_mon + 1;
    debug("Month: ");
    debugln(currentMonth);

    currentYear = ptm->tm_year + 1900;
    debug("Year: ");
    debugln(currentYear);

    //Print complete date:
    currentDate = String(currentMonth) + "-" + String(monthDay) + "-" + String(currentYear);
    debug("Current date: ");
    debugln(currentDate);

    formattedTime = timeClient.getFormattedTime();
    debug("Formatted Time: ");
    debugln(formattedTime);

    bool conectionError = true;

    for (int i = 0; i < 3; i++) {
      if (GSheet.ready()) {
        // Se a conexão estiver pronta, execute as funções relacionadas ao Google Sheets
        loop_enviadorDados();
        loop_receberDados();
        conectionError = false;
        break;  // Sai do loop de tentativas se a conexão estiver pronta
      } else {
        // Set the callback for Google API access token generation status (for debug only)
        //GSheet.setTokenCallback(tokenStatusCallback);

        debugln("Trying to reconnect to Google Sheets...");
        GSheet.setPrerefreshSeconds(10 * 60);
        GSheet.begin(CLIENT_EMAIL, PROJECT_ID, PRIVATE_KEY);
        delay(5000);  // Aguarda um curto período antes de tentar novamente

      }
    }

    if (conectionError) {
      saveValues();
    }
  }
  
   else {
    debugln("Disconnected from Wi-Fi. Reconnecting...");

    WiFi.disconnect();
    delay(500);

    connectWiFi();

    saveValues();

  }

  saveValues();


  //Greenhouse Relay On/Off Logic
  if (grenhouseON == 1) {

    if (humidityEstufa < limiarEstufa) {
      digitalWrite(sprayPin, LOW);
    } else {
      digitalWrite(sprayPin, HIGH);
    }

  } else {

    digitalWrite(sprayPin, HIGH);
  }


  //Irrigation Relay On/Off Logic
  if (soilUmUm < limiteUmidade) {
    
    //check to only runs 1 valve at a time, prevent power supply ishues
    if (humidityEstufa < limiarEstufa) {
      digitalWrite(sprayPin, HIGH);
      delay(1000);
    }

    debugln("Relé Irrigação Acionado");
    digitalWrite(mudasPin, LOW);
    delay(tempoIrrigacao);
    digitalWrite(mudasPin, HIGH);
    debugln("Relé Irrigação Desligado");

    if (humidityEstufa < limiarEstufa) {
      digitalWrite(sprayPin, LOW);
    }
  }


  debugln("Cicle Delay: ");
  debug(tempoCiclo);
  delay(tempoCiclo);

  for (const auto& dados : dadosArmazenados) {
    Serial.println("Epoch Time: " + String(dados.epochTime));
    Serial.println("Current Date: " + dados.currentDate);
    Serial.println("Formatted Time: " + dados.formattedTime);
    Serial.println("Temperature Modulo: " + String(dados.temperatureModulo));
    Serial.println("Humidity Modulo: " + String(dados.humidityModulo));
    Serial.println("Temp Celsius: " + String(dados.TempCelsius));
    Serial.println("Soil UmUm: " + String(dados.soilUmUm));
    Serial.println("Lum PC: " + String(dados.lumPC));
    Serial.println("Soil Cap1: " + String(dados.soilCap1));
    Serial.println("Soil Cap2: " + String(dados.soilCap2));
    Serial.println("Temperature Estufa: " + String(dados.temperatureEstufa));
    Serial.println("Humidity Estufa: " + String(dados.humidityEstufa));
  }

}
