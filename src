
/*******************************************************
 * ESP8266 Saving Values in Ram case internet offline
 * Live data Feed
 * Auto Average Calculation
 *Cache Enought for 100Data readings
 *3 Days in hourly Averages Calculation
 * 06/2024 - Felipe Buhrer
 */
/********************************************************
*/
//Change you Wifi and Gsheets API credentials before use

//Debug State Set
#define DEBUG 1

#if DEBUG == 1
#define debug(x) Serial.print(x)
#define debugln(x) Serial.println(x)
#else
#define debug(x)
#define debugln(x)
#endif

#include <Arduino.h>                  //Overall librarie for commun methods
#include <ESP8266WiFi.h>              //Wifi conection for esp8266
#include <ESP_Google_Sheet_Client.h>  //Send data to Google Sheets
#include <NTPClient.h>                //Get the EPOCH time from web
#include <WiFiUdp.h>                  // Get the EPOCH time from web
#include <ESP8266HTTPClient.h>        //HTTP Client for Conection Test
#include <DHT.h>                      //Read DHT Sensors
#include <vector>                     //Save Ram Data
#include <String>                     //Save Ram Data
#include <ctime>                      //Save Ram Data

#include "envKeys.h"  //Passwords and Autentications keys
unsigned long ms = 0;
unsigned long mr = 0;
unsigned long lastAttemptedReconnect = 0;
void tokenStatusCallback(TokenInfo info);
unsigned long reconnectInterval = 500;
unsigned long lastConectionTest = 0;  //Test Internet pinging google's IP
bool updated = 1;

//Variables for testing on Google Sheets
String sheetAppend = "Medias!";  //Dados
String sheetValues = "Config!";  // Config
String sheetLive = "LiveData!";
//Insert Live Feed

//Temperatura Termistor
#define Vin 3.25          // define constante igual a 5.0
#define T0 298.15         // define constante igual a 298.15 Kelvin
#define Rt 10000          // Resistor do divisor de tensao
#define R0 10000          // Valor da resistencia inicial do NTC
#define T1 273.15         // [K] in datasheet 0o C
#define T2 373.15         // [K] in datasheet 100° C
#define RT1 35563         // [ohms] resistencia in T1
#define RT2 549           // [ohms] resistencia in T2
float beta = 0.0;         // parametros iniciais [K]
float Rinf = 0.0;         // parametros iniciais [ohm]
float TempKelvin = 0.0;   // variable output
float TempCelsius = 0.0;  // variable output
float Vout = 0.0;         // Vout in A0
float Rout = 0.0;

//Define Pins and Sensors
#define mudasPin 2   //D4 turn On plants Relay, runs on Low
#define sprayPin 0   //D3 turn On Greenhouse Umidity Relay, runs on Low
#define DHTESTUFA 5  //D1 Sensor Temp Greenhouse
#define DHTMODULO 4  //D2 Sensor Temp Outside
#define MUXA 13      //D7 Mux channel A
#define MUXB 12      //D6 Mux channel B
#define MUXC 14      //D5 Mux channel C

//Sensores DHT 11
#define DHTTYPE DHT11
DHT dhtModulo(DHTMODULO, DHTTYPE);
uint8_t temperatureModulo = 0;
uint8_t humidityModulo = 0;
DHT dhtEstufa(DHTESTUFA, DHTTYPE);
uint8_t temperatureEstufa = 0;
uint8_t humidityEstufa = 0;

//ALL Sensors
//Termistor Sensor
uint8_t mediaVaristor = 0;
//LDR sensor
uint8_t lumPC = 0;
//Resistive Soil Moisture
uint8_t soilUmUm = 0;
uint8_t AveRes1 = 100;
//Sensor Umidade Solo Capacitivo 1
uint8_t soilCap1 = 0;
uint8_t AveCap1 = 100;
//Sensor Umidade Solo Capacitivo 2
uint8_t soilCap2 = 0;
uint8_t AveCap2 = 100;
//Average Calculation
long somatoria = 0;
uint8_t leitura_sensor = 0;
uint8_t media;
uint8_t leitura;
uint8_t NUMERO_AMOSTRAS = 40;  //Number of readings per Average

//uint8_t averageCalculationInterval = 0;

//Epoch Time Config
const long utcOffsetInSeconds = -10800;  //Ajuste de data e hora
// Define NTP Client to get time
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org");
//Variaveis data e hora
time_t epochTime = 1718193152;  //Set if bad conection, first readings may need it.
uint8_t monthDay;
uint8_t currentMonth;
uint16_t currentYear;
String currentDate;
char formattedTime[20];


//---** Variables Changed on Sheets Loop Recebedor
//Variables for cicle Delays and Irrigation system
unsigned long readingInterval = 60000;               //1min
//Greenhour trigger treshhold
uint16_t limiarEstufa = 80;
//Greenhous Activity on/off
bool grenhouseON = 1;
//Irrigation system Timer
unsigned long tempoIrrigacao = 0;
//Lowet humidity before start irrigation
uint16_t limiteUmidade = 40;                    //45%

//uint32_t sendDataInterval = 3600000;  //1 Hour //REMOVER

//Time to Upate Config Interval
unsigned long recivingDataInterval = 60000;  //change again 5 minutes
//Automatic Irrigation System On/Off
bool autoIr = 0;
//One time irrigation Start
bool externalIrReq = 0;



uint32_t betweenIrInterval = 3600000;

//Counters
unsigned long lastReading = 0;
unsigned long lastSendedData = 0;
unsigned long lastUpdate = 0;
unsigned long lastIrrigation = 0;
unsigned long previousMillis = 0;
unsigned long irrigationStartMillis = 0;
uint8_t numAverages = 0;  // Contador de médias calculadas


uint8_t maxTemp = 0;   //Will be updated every cicle and send the max values
uint8_t minTemp = 80;  //Will be updated every cicle and send the min values

enum State {
  IDLE,
  IRRIGATION_ON,
  IRRIGATION_WAIT,
  IRRIGATION_OFF
};



// Variáveis globais para armazenar condições
bool isSpraying = false;
State currentState = IDLE;

//--------------------------Methods
//Connect Wifi
void connectWiFi();
bool testInternetConnection();
// Crie uma instância do WiFiClient
WiFiClient wifiClient;

//**Sensors
//Mux Readings
void muxReadings();
//dht11
void Load_DHT11_Data();
//Leitura Sensores Resistivos
uint8_t readPin();
//Mux port selection code
void selectChannel();
//Calculate Epoch Dependent Variables
void epochCalculate(time_t);

//**Gsheets --
void tokenStatusCallback();
//Enviador de Dados
void sendLiveData();
//Recebedor de Dados
void loop_receberDados();
//Update External Irrigation Request
void updateExterReq();

// Struct definition to save all data formats
struct Dados {
  time_t epochTime;
  uint8_t temperatureModulo;
  uint8_t humidityModulo;
  uint8_t TempCelsius;
  uint8_t soilUmUm;
  uint8_t lumPC;
  uint8_t soilCap1;
  uint8_t soilCap2;
  uint8_t temperatureEstufa;
  uint8_t humidityEstufa;
  uint8_t maxTemp;
  uint8_t minTemp;
};



//**Saving data to RAM
// Struct definition to save all data formats
struct Dados;
//Max reading number before Average Calculation
const uint8_t numReadings = 60; //***Cahnge to 60
// Struct Vector to storage readings
Dados readings[numReadings];
uint8_t currentIndex = 0;  // Índex for the position
size_t freeHeap = 0;

//Method for saving values in RAM for 60 readings
void addReading();
void calculateAverages();
void sendAndClearData();


// Vector para armazenar os conjuntos de dados das médias ja calculatas
std::vector<Dados> averageStorage;  //Uses array in stack for that

//--------------Setup
void setup() {

  Serial.begin(115200);

  //DHT sensores
  dhtModulo.begin();
  dhtEstufa.begin();

  //Thermistor Calculation
  beta = (log(RT1 / RT2)) / ((1 / T1) - (1 / T2));  // calculo de beta
  Rinf = R0 * exp(-beta / T0);                      // calculo de Rinf

  // Mux pins as OUTPUTS
  pinMode(MUXA, OUTPUT);
  pinMode(MUXB, OUTPUT);
  pinMode(MUXC, OUTPUT);

  //Greenhouse relay pin
  pinMode(sprayPin, OUTPUT);
  digitalWrite(sprayPin, HIGH);

  //Irrigation System Pin
  pinMode(mudasPin, OUTPUT);
  digitalWrite(mudasPin, HIGH);

  //Client Check
  //GSheet.printf("ESP Google Sheet Client v%s\n\n", ESP_GOOGLE_SHEET_CLIENT_VERSION);

  //WiFi Novo
  connectWiFi();

  //Inicializando Gsheets
  if (WiFi.status() == WL_CONNECTED) {
    debugln("\nWi-Fi connected!");

    // Set the callback for Google API access token generation status (for debug only)
    GSheet.setTokenCallback(tokenStatusCallback);
    GSheet.setPrerefreshSeconds(10 * 60);
    GSheet.begin(CLIENT_EMAIL, PROJECT_ID, PRIVATE_KEY);

  } else {
    debugln("\nFailed to connect to Wi-Fi!");
  }

  // Initialize a NTPClient to get time
  timeClient.begin();
  timeClient.setTimeOffset(-10800);
}


void loop() {

  unsigned long currentMillis = millis();

  //Mux readings//Maybe cut out
  muxReadings();
  Load_DHT11_Data();

  timeClient.update();
  epochTime = timeClient.getEpochTime();
  epochCalculate(epochTime);

  //debugln("******************");
  //debugln(currentState);
  //debugln("*******");

  //Test internet conection pingin google's ip
  if (currentMillis - lastConectionTest >= 3600000) {

    //Serial.println("chamando o teste de internt");
    updated = testInternetConnection();
    lastConectionTest = currentMillis;
  }

  // Updating Data
  if (currentMillis - lastUpdate > recivingDataInterval && updated) {  //1min teste
   Serial.print("Chamando o loop recebedor de dados");
    //debugln("Updating Values");
    loop_receberDados();
    lastUpdate = currentMillis;
     Serial.print("Deu boa o recebedor de dados");
  }


  //External Request of Irrigation Logic
  if (externalIrReq) {

    // Verifica se o pino da estufa está ligado e desliga se necessário
    if (isSpraying) {
      //debugln("**Spray LIGADO Status Check condicao 1");
      digitalWrite(sprayPin, HIGH);
      isSpraying = false;
      //debugln("**Spray DESLIGADO PELA CONDICAO 1");
    }
    // Liga o pino de irrigação e marca o início
    digitalWrite(mudasPin, LOW);
    // debugln("Relé Irrigação Acionado");
    irrigationStartMillis = currentMillis;
    currentState = IRRIGATION_ON;
    externalIrReq = 0;
  }


  //Irrigation Logic
  switch (currentState) {

    case IDLE:
      if (autoIr) {
        if (currentMillis - lastIrrigation >= betweenIrInterval) {
          if (AveCap1 < limiteUmidade && tempoIrrigacao > 0) {
              // Verifica se o pino da estufa está ligado e desliga se necessário
            if (isSpraying) {
              //debugln("**Spray LIGADO Status Check condicao 1");
              digitalWrite(sprayPin, HIGH);
              isSpraying = false;
              //debugln("**Spray DESLIGADO PELA CONDICAO 1");
            }
            // Liga o pino de irrigação e marca o início
            digitalWrite(mudasPin, LOW);
            // debugln("Relé Irrigação Acionado");
            irrigationStartMillis = currentMillis;
            currentState = IRRIGATION_ON;
          }
        }
      } else if (grenhouseON && humidityEstufa < limiarEstufa) {
        if (!isSpraying) {
          digitalWrite(sprayPin, LOW);
          isSpraying = true;
          //debugln("**Spray LIGADO pelo esleif da condição 1");
        }
      } else if (!grenhouseON) {
        if (isSpraying) {
          digitalWrite(sprayPin, HIGH);
          isSpraying = false;
          //debugln("**Spray DESLIGADO pelo esleif da condição 1");
        }
      }
      break;

    case IRRIGATION_ON:
      currentState = IRRIGATION_WAIT;
      break;

    case IRRIGATION_WAIT:
      // Espera até que a duração da irrigação tenha passado
      if (currentMillis - irrigationStartMillis >= tempoIrrigacao) {
        digitalWrite(mudasPin, HIGH);
        // debugln("Relé Irrigação Desligado");
        currentState = IRRIGATION_OFF;
      }
      break;

    case IRRIGATION_OFF:
      //debugln("**Iniciando Condição 4");
      // Restaura o estado do pino da estufa se necessário
      if (humidityEstufa < limiarEstufa && grenhouseON) {
        if (!isSpraying) {
          digitalWrite(sprayPin, LOW);
          isSpraying = true;
          //debugln("**Spray LIGADO pela condicao 4");
        }
      }
      lastIrrigation = currentMillis;
      currentState = IDLE;
      break;
  }



  //Reading Iterval & Live Data Logic
  if (currentMillis - lastReading >= readingInterval) {

    lastReading = currentMillis;
    //sendLiveData();
    addReading();
  }
 // Serial.println();
  //Serial.print("currentIndex: ");
 // Serial.println(currentIndex);
  //Serial.println();
  //Serial.print("Average Store Size: ");
  //Serial.println(averageStorage.size());


  //Send Data 
  //Last for EpochLogic
  if (averageStorage.size() > 100) {

    if (WiFi.status() == WL_CONNECTED) {
      // Verificar a conexão com a Internet antes de enviar os dados
      if (updated) {
        // if (currentMillis - lastSendedData >= sendDataInterval) {
        //Change here for if have any objetec in average store
        sendAndClearData();
        //lastSendedData = currentMillis;
        // }
      } else {
        // Se não houver conexão com a Internet, tentar reconectar
        if (currentMillis - lastAttemptedReconnect >= reconnectInterval) {
          lastAttemptedReconnect = currentMillis;
          connectWiFi();  // Tentar reconectar
        }
      }
    } else {
      // Tentar reconectar se não estiver conectado ao WiFi
      if (currentMillis - lastAttemptedReconnect >= reconnectInterval) {
        lastAttemptedReconnect = currentMillis;
        connectWiFi();  // Tentar reconectar
      }
    }
  }


  // Verifica a quantidade de memória heap livre
  freeHeap = ESP.getFreeHeap();
  Serial.print("Free heap: ");
  Serial.print(freeHeap);
  Serial.println(" bytes");

  //Serial.print("Tamanho dados armazenados :");
  //Serial.println(dadosArmazenados.size());
}